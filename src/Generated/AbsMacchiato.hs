-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Generated.AbsMacchiato where

import Prelude (Char, Double, Integer, String, map, fmap)
import qualified Prelude as C (Eq, Ord, Show, Read, Functor)
import qualified Data.String

newtype UIdent = UIdent String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

data Program a = ProgramS a [FnDef a]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Program where
    fmap f x = case x of
        ProgramS a fndefs -> ProgramS (f a) (map (fmap f) fndefs)

data FnDef a = FunDef a (Type a) UIdent [Arg a] (Block a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor FnDef where
    fmap f x = case x of
        FunDef a type_ uident args block -> FunDef (f a) (fmap f type_) uident (map (fmap f) args) (fmap f block)

data Arg a = ArgVal a (Type a) UIdent | ArgRef a (Type a) UIdent
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Arg where
    fmap f x = case x of
        ArgVal a type_ uident -> ArgVal (f a) (fmap f type_) uident
        ArgRef a type_ uident -> ArgRef (f a) (fmap f type_) uident

data Block a = FunBlock a [Stmt a]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Block where
    fmap f x = case x of
        FunBlock a stmts -> FunBlock (f a) (map (fmap f) stmts)

data Stmt a
    = Empty a
    | BStmt a (Block a)
    | FunStmt a (FnDef a)
    | Decl a (Type a) [Item a]
    | Ass a UIdent (Expr a)
    | ArrAss a UIdent [DimAcc a] (Expr a)
    | Ret a (Expr a)
    | Cond a (Expr a) (Stmt a)
    | CondElse a (Expr a) (Stmt a) (Stmt a)
    | While a (Expr a) (Stmt a)
    | SExp a (Expr a)
    | Print a [PrintParam a]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Stmt where
    fmap f x = case x of
        Empty a -> Empty (f a)
        BStmt a block -> BStmt (f a) (fmap f block)
        FunStmt a fndef -> FunStmt (f a) (fmap f fndef)
        Decl a type_ items -> Decl (f a) (fmap f type_) (map (fmap f) items)
        Ass a uident expr -> Ass (f a) uident (fmap f expr)
        ArrAss a uident dimaccs expr -> ArrAss (f a) uident (map (fmap f) dimaccs) (fmap f expr)
        Ret a expr -> Ret (f a) (fmap f expr)
        Cond a expr stmt -> Cond (f a) (fmap f expr) (fmap f stmt)
        CondElse a expr stmt1 stmt2 -> CondElse (f a) (fmap f expr) (fmap f stmt1) (fmap f stmt2)
        While a expr stmt -> While (f a) (fmap f expr) (fmap f stmt)
        SExp a expr -> SExp (f a) (fmap f expr)
        Print a printparams -> Print (f a) (map (fmap f) printparams)

data Item a = NoInit a UIdent | Init a UIdent (Expr a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Item where
    fmap f x = case x of
        NoInit a uident -> NoInit (f a) uident
        Init a uident expr -> Init (f a) uident (fmap f expr)

data PrintParam a = FunPrintParam a (Expr a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor PrintParam where
    fmap f x = case x of
        FunPrintParam a expr -> FunPrintParam (f a) (fmap f expr)

data Type a
    = Int a
    | Str a
    | Bool a
    | Arr a (Type a) [DimBra a]
    | Fun a (Type a) [Type a]
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Type where
    fmap f x = case x of
        Int a -> Int (f a)
        Str a -> Str (f a)
        Bool a -> Bool (f a)
        Arr a type_ dimbras -> Arr (f a) (fmap f type_) (map (fmap f) dimbras)
        Fun a type_ types -> Fun (f a) (fmap f type_) (map (fmap f) types)

data DimBra a = ModDimBra a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor DimBra where
    fmap f x = case x of
        ModDimBra a -> ModDimBra (f a)

data Expr a
    = EVar a UIdent
    | ENewArr a (Type a) [DimAcc a] [DimBra a]
    | EArrAcc a UIdent [DimAcc a]
    | EKeyWord a UIdent (KeyWord a)
    | EArrKeyWord a UIdent [DimAcc a] (KeyWord a)
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EApp a UIdent [Expr a]
    | EString a String
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor Expr where
    fmap f x = case x of
        EVar a uident -> EVar (f a) uident
        ENewArr a type_ dimaccs dimbras -> ENewArr (f a) (fmap f type_) (map (fmap f) dimaccs) (map (fmap f) dimbras)
        EArrAcc a uident dimaccs -> EArrAcc (f a) uident (map (fmap f) dimaccs)
        EKeyWord a uident keyword -> EKeyWord (f a) uident (fmap f keyword)
        EArrKeyWord a uident dimaccs keyword -> EArrKeyWord (f a) uident (map (fmap f) dimaccs) (fmap f keyword)
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a uident exprs -> EApp (f a) uident (map (fmap f) exprs)
        EString a string -> EString (f a) string
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)

data DimAcc a = EDimAcc a (Expr a)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor DimAcc where
    fmap f x = case x of
        EDimAcc a expr -> EDimAcc (f a) (fmap f expr)

data KeyWord a = KeyWordLength a | KeyWordMaxVal a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor KeyWord where
    fmap f x = case x of
        KeyWordLength a -> KeyWordLength (f a)
        KeyWordMaxVal a -> KeyWordMaxVal (f a)

data AddOp a = Plus a | Minus a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)

data MulOp a = Times a | Div a | Mod a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)

data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (C.Eq, C.Ord, C.Show, C.Read)

instance C.Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)

