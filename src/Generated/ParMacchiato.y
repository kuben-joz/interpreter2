-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParMacchiato where
import qualified AbsMacchiato
import LexMacchiato
}

%name pProgram Program
-- no lexer declaration
%monad { Either String } { (>>=) } { return }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '&&' { PT _ (TS _ 5) }
  '(' { PT _ (TS _ 6) }
  ')' { PT _ (TS _ 7) }
  '*' { PT _ (TS _ 8) }
  '+' { PT _ (TS _ 9) }
  ',' { PT _ (TS _ 10) }
  '-' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  '::' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<<' { PT _ (TS _ 16) }
  '<=' { PT _ (TS _ 17) }
  '=' { PT _ (TS _ 18) }
  '==' { PT _ (TS _ 19) }
  '>' { PT _ (TS _ 20) }
  '>=' { PT _ (TS _ 21) }
  'LENGTH' { PT _ (TS _ 22) }
  'MAX_VAL' { PT _ (TS _ 23) }
  '[' { PT _ (TS _ 24) }
  '[]' { PT _ (TS _ 25) }
  ']' { PT _ (TS _ 26) }
  'bool' { PT _ (TS _ 27) }
  'else' { PT _ (TS _ 28) }
  'false' { PT _ (TS _ 29) }
  'if' { PT _ (TS _ 30) }
  'int' { PT _ (TS _ 31) }
  'new' { PT _ (TS _ 32) }
  'print' { PT _ (TS _ 33) }
  'return' { PT _ (TS _ 34) }
  'string' { PT _ (TS _ 35) }
  'true' { PT _ (TS _ 36) }
  'while' { PT _ (TS _ 37) }
  '{' { PT _ (TS _ 38) }
  '||' { PT _ (TS _ 39) }
  '}' { PT _ (TS _ 40) }
  L_integ  { PT _ (TI $$) }
  L_quoted { PT _ (TL $$) }
  L_UIdent { PT _ (T_UIdent $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read ($1)) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

UIdent :: { AbsMacchiato.UIdent}
UIdent  : L_UIdent { AbsMacchiato.UIdent $1 }

Program :: { (AbsMacchiato.Program ()) }
Program : ListFnDef { AbsMacchiato.ProgramS () $1 }

FnDef :: { (AbsMacchiato.FnDef ()) }
FnDef : Type UIdent '(' ListArg ')' Block { AbsMacchiato.FunDef () $1 $2 $4 $6 }

ListFnDef :: { [AbsMacchiato.FnDef ()] }
ListFnDef : FnDef { (:[]) $1 } | FnDef ListFnDef { (:) $1 $2 }

Arg :: { (AbsMacchiato.Arg ()) }
Arg : Type UIdent { AbsMacchiato.ArgVal () $1 $2 }
    | Type '&' UIdent { AbsMacchiato.ArgRef () $1 $3 }

ListArg :: { [AbsMacchiato.Arg ()] }
ListArg : {- empty -} { [] }
        | Arg { (:[]) $1 }
        | Arg ',' ListArg { (:) $1 $3 }

Block :: { (AbsMacchiato.Block ()) }
Block : '{' ListStmt '}' { AbsMacchiato.FunBlock () $2 }

ListStmt :: { [AbsMacchiato.Stmt ()] }
ListStmt : {- empty -} { [] } | Stmt ListStmt { (:) $1 $2 }

Stmt :: { (AbsMacchiato.Stmt ()) }
Stmt : ';' { AbsMacchiato.Empty () }
     | Block { AbsMacchiato.BStmt () $1 }
     | FnDef { AbsMacchiato.FunStmt () $1 }
     | Type ListItem ';' { AbsMacchiato.Decl () $1 $2 }
     | UIdent '=' Expr ';' { AbsMacchiato.Ass () $1 $3 }
     | UIdent ListDimAcc '=' Expr ';' { AbsMacchiato.ArrAss () $1 $2 $4 }
     | 'return' Expr ';' { AbsMacchiato.Ret () $2 }
     | 'if' '(' Expr ')' Stmt { AbsMacchiato.Cond () $3 $5 }
     | 'if' '(' Expr ')' Stmt 'else' Stmt { AbsMacchiato.CondElse () $3 $5 $7 }
     | 'while' '(' Expr ')' Stmt { AbsMacchiato.While () $3 $5 }
     | Expr ';' { AbsMacchiato.SExp () $1 }
     | 'print' ListPrintParam ';' { AbsMacchiato.Print () $2 }

Item :: { (AbsMacchiato.Item ()) }
Item : UIdent { AbsMacchiato.NoInit () $1 }
     | UIdent '=' Expr { AbsMacchiato.Init () $1 $3 }

ListItem :: { [AbsMacchiato.Item ()] }
ListItem : Item { (:[]) $1 } | Item ',' ListItem { (:) $1 $3 }

PrintParam :: { (AbsMacchiato.PrintParam ()) }
PrintParam : '<<' Expr { AbsMacchiato.FunPrintParam () $2 }

ListPrintParam :: { [AbsMacchiato.PrintParam ()] }
ListPrintParam : PrintParam { (:[]) $1 }
               | PrintParam ListPrintParam { (:) $1 $2 }

Type :: { (AbsMacchiato.Type ()) }
Type : 'int' { AbsMacchiato.Int () }
     | 'string' { AbsMacchiato.Str () }
     | 'bool' { AbsMacchiato.Bool () }
     | Type ListDimBra { AbsMacchiato.Arr () $1 $2 }

DimBra :: { (AbsMacchiato.DimBra ()) }
DimBra : '[]' { AbsMacchiato.ModDimBra () }

ListDimBra :: { [AbsMacchiato.DimBra ()] }
ListDimBra : DimBra { (:[]) $1 } | DimBra ListDimBra { (:) $1 $2 }

ListType :: { [AbsMacchiato.Type ()] }
ListType : {- empty -} { [] }
         | Type { (:[]) $1 }
         | Type ',' ListType { (:) $1 $3 }

Expr6 :: { AbsMacchiato.Expr () }
Expr6 : UIdent { AbsMacchiato.EVar () $1 }
      | 'new' Type ListDimAcc ListDimBra { AbsMacchiato.ENewArr () $2 $3 $4 }
      | UIdent ListDimAcc { AbsMacchiato.EArrAcc () $1 $2 }
      | UIdent '::' KeyWord { AbsMacchiato.EKeyWord () $1 $3 }
      | UIdent ListDimAcc '::' KeyWord { AbsMacchiato.EArrKeyWord () $1 $2 $4 }
      | Integer { AbsMacchiato.ELitInt () $1 }
      | 'true' { AbsMacchiato.ELitTrue () }
      | 'false' { AbsMacchiato.ELitFalse () }
      | UIdent '(' ListExpr ')' { AbsMacchiato.EApp () $1 $3 }
      | String { AbsMacchiato.EString () $1 }
      | '(' Expr ')' { $2 }

DimAcc :: { (AbsMacchiato.DimAcc ()) }
DimAcc : '[' Expr6 ']' { AbsMacchiato.EDimAcc () $2 }

ListDimAcc :: { [AbsMacchiato.DimAcc ()] }
ListDimAcc : DimAcc { (:[]) $1 } | DimAcc ListDimAcc { (:) $1 $2 }

KeyWord :: { (AbsMacchiato.KeyWord ()) }
KeyWord : 'LENGTH' { AbsMacchiato.KeyWordLength () }
        | 'MAX_VAL' { AbsMacchiato.KeyWordMaxVal () }

Expr5 :: { AbsMacchiato.Expr () }
Expr5 : '-' Expr6 { AbsMacchiato.Neg () $2 }
      | '!' Expr6 { AbsMacchiato.Not () $2 }
      | Expr6 { $1 }

Expr4 :: { AbsMacchiato.Expr () }
Expr4 : Expr4 MulOp Expr5 { AbsMacchiato.EMul () $1 $2 $3 }
      | Expr5 { $1 }

Expr3 :: { AbsMacchiato.Expr () }
Expr3 : Expr3 AddOp Expr4 { AbsMacchiato.EAdd () $1 $2 $3 }
      | Expr4 { $1 }

Expr2 :: { AbsMacchiato.Expr () }
Expr2 : Expr2 RelOp Expr3 { AbsMacchiato.ERel () $1 $2 $3 }
      | Expr3 { $1 }

Expr1 :: { AbsMacchiato.Expr () }
Expr1 : Expr2 '&&' Expr1 { AbsMacchiato.EAnd () $1 $3 }
      | Expr2 { $1 }

Expr :: { (AbsMacchiato.Expr ()) }
Expr : Expr1 '||' Expr { AbsMacchiato.EOr () $1 $3 } | Expr1 { $1 }

ListExpr :: { [AbsMacchiato.Expr ()] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }

AddOp :: { (AbsMacchiato.AddOp ()) }
AddOp : '+' { AbsMacchiato.Plus () }
      | '-' { AbsMacchiato.Minus () }

MulOp :: { (AbsMacchiato.MulOp ()) }
MulOp : '*' { AbsMacchiato.Times () }
      | '/' { AbsMacchiato.Div () }
      | '%' { AbsMacchiato.Mod () }

RelOp :: { (AbsMacchiato.RelOp ()) }
RelOp : '<' { AbsMacchiato.LTH () }
      | '<=' { AbsMacchiato.LE () }
      | '>' { AbsMacchiato.GTH () }
      | '>=' { AbsMacchiato.GE () }
      | '==' { AbsMacchiato.EQU () }
      | '!=' { AbsMacchiato.NE () }
{

happyError :: [Token] -> Either String a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer = tokens
}

