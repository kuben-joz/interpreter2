-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParMacchiato
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified AbsMacchiato
import LexMacchiato

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'       { PT _ (TS _ 1)     }
  '!='      { PT _ (TS _ 2)     }
  '%'       { PT _ (TS _ 3)     }
  '&'       { PT _ (TS _ 4)     }
  '&&'      { PT _ (TS _ 5)     }
  '('       { PT _ (TS _ 6)     }
  ')'       { PT _ (TS _ 7)     }
  '*'       { PT _ (TS _ 8)     }
  '+'       { PT _ (TS _ 9)     }
  ','       { PT _ (TS _ 10)    }
  '-'       { PT _ (TS _ 11)    }
  '/'       { PT _ (TS _ 12)    }
  '::'      { PT _ (TS _ 13)    }
  ';'       { PT _ (TS _ 14)    }
  '<'       { PT _ (TS _ 15)    }
  '<<'      { PT _ (TS _ 16)    }
  '<='      { PT _ (TS _ 17)    }
  '='       { PT _ (TS _ 18)    }
  '=='      { PT _ (TS _ 19)    }
  '>'       { PT _ (TS _ 20)    }
  '>='      { PT _ (TS _ 21)    }
  'LENGTH'  { PT _ (TS _ 22)    }
  'MAX_VAL' { PT _ (TS _ 23)    }
  '['       { PT _ (TS _ 24)    }
  '[]'      { PT _ (TS _ 25)    }
  ']'       { PT _ (TS _ 26)    }
  'bool'    { PT _ (TS _ 27)    }
  'else'    { PT _ (TS _ 28)    }
  'false'   { PT _ (TS _ 29)    }
  'if'      { PT _ (TS _ 30)    }
  'int'     { PT _ (TS _ 31)    }
  'new'     { PT _ (TS _ 32)    }
  'print'   { PT _ (TS _ 33)    }
  'return'  { PT _ (TS _ 34)    }
  'string'  { PT _ (TS _ 35)    }
  'true'    { PT _ (TS _ 36)    }
  'while'   { PT _ (TS _ 37)    }
  '{'       { PT _ (TS _ 38)    }
  '||'      { PT _ (TS _ 39)    }
  '}'       { PT _ (TS _ 40)    }
  L_integ   { PT _ (TI _)       }
  L_quoted  { PT _ (TL _)       }
  L_UIdent  { PT _ (T_UIdent _) }

%%

Integer :: { (AbsMacchiato.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (AbsMacchiato.BNFC'Position, String) }
String   : L_quoted { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

UIdent :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.UIdent) }
UIdent  : L_UIdent { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.UIdent (tokenText $1)) }

Program :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Program) }
Program
  : ListFnDef { (fst $1, AbsMacchiato.ProgramS (fst $1) (snd $1)) }

FnDef :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.FnDef) }
FnDef
  : Type UIdent '(' ListArg ')' Block { (fst $1, AbsMacchiato.FunDef (fst $1) (snd $1) (snd $2) (snd $4) (snd $6)) }

ListFnDef :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.FnDef]) }
ListFnDef
  : FnDef { (fst $1, (:[]) (snd $1)) }
  | FnDef ListFnDef { (fst $1, (:) (snd $1) (snd $2)) }

Arg :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Arg) }
Arg
  : Type UIdent { (fst $1, AbsMacchiato.ArgVal (fst $1) (snd $1) (snd $2)) }
  | Type '&' UIdent { (fst $1, AbsMacchiato.ArgRef (fst $1) (snd $1) (snd $3)) }

ListArg :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.Arg]) }
ListArg
  : {- empty -} { (AbsMacchiato.BNFC'NoPosition, []) }
  | Arg { (fst $1, (:[]) (snd $1)) }
  | Arg ',' ListArg { (fst $1, (:) (snd $1) (snd $3)) }

Block :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Block) }
Block
  : '{' ListStmt '}' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.FunBlock (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListStmt :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.Stmt]) }
ListStmt
  : {- empty -} { (AbsMacchiato.BNFC'NoPosition, []) }
  | Stmt ListStmt { (fst $1, (:) (snd $1) (snd $2)) }

Stmt :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Stmt) }
Stmt
  : ';' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Empty (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | Block { (fst $1, AbsMacchiato.BStmt (fst $1) (snd $1)) }
  | FnDef { (fst $1, AbsMacchiato.FunStmt (fst $1) (snd $1)) }
  | Type ListItem ';' { (fst $1, AbsMacchiato.Decl (fst $1) (snd $1) (snd $2)) }
  | UIdent '=' Expr ';' { (fst $1, AbsMacchiato.Ass (fst $1) (snd $1) (snd $3)) }
  | UIdent ListDimAcc '=' Expr ';' { (fst $1, AbsMacchiato.ArrAss (fst $1) (snd $1) (snd $2) (snd $4)) }
  | 'return' Expr ';' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Ret (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'if' '(' Expr ')' Stmt { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Cond (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | 'if' '(' Expr ')' Stmt 'else' Stmt { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.CondElse (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $7)) }
  | 'while' '(' Expr ')' Stmt { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.While (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }
  | Expr ';' { (fst $1, AbsMacchiato.SExp (fst $1) (snd $1)) }
  | 'print' ListPrintParam ';' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Print (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Item :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Item) }
Item
  : UIdent { (fst $1, AbsMacchiato.NoInit (fst $1) (snd $1)) }
  | UIdent '=' Expr { (fst $1, AbsMacchiato.Init (fst $1) (snd $1) (snd $3)) }

ListItem :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.Item]) }
ListItem
  : Item { (fst $1, (:[]) (snd $1)) }
  | Item ',' ListItem { (fst $1, (:) (snd $1) (snd $3)) }

PrintParam :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.PrintParam) }
PrintParam
  : '<<' Expr { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.FunPrintParam (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListPrintParam :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.PrintParam]) }
ListPrintParam
  : PrintParam { (fst $1, (:[]) (snd $1)) }
  | PrintParam ListPrintParam { (fst $1, (:) (snd $1) (snd $2)) }

Type :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Type) }
Type
  : 'int' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Int (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | 'string' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Str (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | 'bool' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Bool (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | Type '[]' ListDimBra { (fst $1, AbsMacchiato.Arr (fst $1) (snd $1) (snd $3)) }

DimBra :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.DimBra) }
DimBra
  : '[]' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.ModDimBra (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }

ListDimBra :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.DimBra]) }
ListDimBra
  : {- empty -} { (AbsMacchiato.BNFC'NoPosition, []) }
  | DimBra ListDimBra { (fst $1, (:) (snd $1) (snd $2)) }

ListType :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.Type]) }
ListType
  : {- empty -} { (AbsMacchiato.BNFC'NoPosition, []) }
  | Type { (fst $1, (:[]) (snd $1)) }
  | Type ',' ListType { (fst $1, (:) (snd $1) (snd $3)) }

Expr6 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr6
  : UIdent { (fst $1, AbsMacchiato.EVar (fst $1) (snd $1)) }
  | 'new' Type ListDimAcc ListDimBra { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.ENewArr (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $4)) }
  | UIdent ListDimAcc { (fst $1, AbsMacchiato.EArrAcc (fst $1) (snd $1) (snd $2)) }
  | UIdent '::' KeyWord { (fst $1, AbsMacchiato.EKeyWord (fst $1) (snd $1) (snd $3)) }
  | UIdent ListDimAcc '::' KeyWord { (fst $1, AbsMacchiato.EArrKeyWord (fst $1) (snd $1) (snd $2) (snd $4)) }
  | Integer { (fst $1, AbsMacchiato.ELitInt (fst $1) (snd $1)) }
  | 'true' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.ELitTrue (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | 'false' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.ELitFalse (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | UIdent '(' ListExpr ')' { (fst $1, AbsMacchiato.EApp (fst $1) (snd $1) (snd $3)) }
  | String { (fst $1, AbsMacchiato.EString (fst $1) (snd $1)) }
  | '(' Expr ')' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), (snd $2)) }

DimAcc :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.DimAcc) }
DimAcc
  : '[' Expr6 ']' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.EDimAcc (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListDimAcc :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.DimAcc]) }
ListDimAcc
  : DimAcc { (fst $1, (:[]) (snd $1)) }
  | DimAcc ListDimAcc { (fst $1, (:) (snd $1) (snd $2)) }

KeyWord :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.KeyWord) }
KeyWord
  : 'LENGTH' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.KeyWordLength (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | 'MAX_VAL' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.KeyWordMaxVal (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }

Expr5 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr5
  : '-' Expr6 { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Neg (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '!' Expr6 { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Not (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr6 { (fst $1, (snd $1)) }

Expr4 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr4
  : Expr4 MulOp Expr5 { (fst $1, AbsMacchiato.EMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr5 { (fst $1, (snd $1)) }

Expr3 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr3
  : Expr3 AddOp Expr4 { (fst $1, AbsMacchiato.EAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr4 { (fst $1, (snd $1)) }

Expr2 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr2
  : Expr2 RelOp Expr3 { (fst $1, AbsMacchiato.ERel (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

Expr1 :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr1
  : Expr2 '&&' Expr1 { (fst $1, AbsMacchiato.EAnd (fst $1) (snd $1) (snd $3)) }
  | Expr2 { (fst $1, (snd $1)) }

Expr :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.Expr) }
Expr
  : Expr1 '||' Expr { (fst $1, AbsMacchiato.EOr (fst $1) (snd $1) (snd $3)) }
  | Expr1 { (fst $1, (snd $1)) }

ListExpr :: { (AbsMacchiato.BNFC'Position, [AbsMacchiato.Expr]) }
ListExpr
  : {- empty -} { (AbsMacchiato.BNFC'NoPosition, []) }
  | Expr { (fst $1, (:[]) (snd $1)) }
  | Expr ',' ListExpr { (fst $1, (:) (snd $1) (snd $3)) }

AddOp :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.AddOp) }
AddOp
  : '+' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Plus (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Minus (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.MulOp) }
MulOp
  : '*' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Times (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Div (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.Mod (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }

RelOp :: { (AbsMacchiato.BNFC'Position, AbsMacchiato.RelOp) }
RelOp
  : '<' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.LTH (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.LE (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.GTH (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.GE (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '==' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.EQU (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1), AbsMacchiato.NE (uncurry AbsMacchiato.BNFC'Position (tokenLineCol $1))) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err AbsMacchiato.Program
pProgram = fmap snd . pProgram_internal
}

